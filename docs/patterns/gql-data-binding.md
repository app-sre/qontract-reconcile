# GraphQL Data Binding with `qenerate`

A core pattern in `qontract-reconcile` is the use of `qenerate`, a tool that automatically generates Pydantic data classes from GraphQL queries. This provides a robust, type-safe way to fetch the desired state for an integration from `app-interface`.

This approach avoids manual dictionary parsing and provides benefits like static type checking with `mypy` and editor autocompletion.

## The `qenerate` Workflow

The process involves three main steps:

**1. Define a GraphQL Query (`.gql` file)**

First, you create a `.gql` file in the `reconcile/gql_definitions/` directory (usually within a subdirectory for your integration). This file defines the data your integration needs.

*Example: `reconcile/gql_definitions/glitchtip/glitchtip_instance.gql`*
```graphql
# qenerate: plugin=pydantic_v1

query GlitchtipInstances {
  glitchtip_instances: glitchtip_instances_v1 {
    name
    readToken {
      ...VaultSecret
    }
  }
}

fragment VaultSecret on VaultSecret_v1 {
  path
  field
  version
  format
}
```
**Note:** The `# qenerate: plugin=pydantic_v1` comment is mandatory.

**2. Generate Python Code**

Ensure you run a local grahql server on `localhost:4000` with up-to-date schemas.

Next, you run the `make qenerate` command from the root of the repository. This command performs two actions:
- `make gql-introspection`: Fetches the latest GraphQL schema from the server.
- `make gql-query-classes`: Reads your `.gql` file and the schema, and generates a corresponding Python module.

This will create a `glitchtip_instance.py` file next to your `.gql` file, containing Pydantic models that match the query structure.

*Generated file: `reconcile/gql_definitions/glitchtip/glitchtip_instance.py` (simplified)*
```python
# Generated by qenerate plugin=pydantic_v1. DO NOT MODIFY MANUALLY!

# ... imports ...

class VaultSecretV1(ConfiguredBaseModel):
    path: str = Field(..., alias="path")
    # ... other fields ...

class GlitchtipInstanceV1(ConfiguredBaseModel):
    name: str = Field(..., alias="name")
    read_token: VaultSecretV1 = Field(..., alias="readToken")

class GlitchtipInstancesQueryData(ConfiguredBaseModel):
    glitchtip_instances: Optional[list[GlitchtipInstanceV1]] = Field(..., alias="glitchtip_instances")

def query(query_func: Callable, **kwargs: Any) -> GlitchtipInstancesQueryData:
    """
    This is a convenience function which queries and parses the data into
    concrete types. It should be compatible with most GQL clients.
    You do not have to use it to consume the generated data classes.
    """
    raw_data: dict[Any, Any] = query_func(QUERY, **kwargs)
    return GlitchtipInstancesQueryData(**raw_data)
```

**3. Use the Generated Code in an Integration**

Finally, you can import and use the generated `query()` function in your integration. This gives you fully typed objects to work with.

*Example: `reconcile/glitchtip/integration.py`*
```python
from reconcile.gql_definitions.glitchtip import glitchtip_instance
from reconcile.utils import gql

def get_glitchtip_instances(query_func: Callable) -> list[glitchtip_instance.GlitchtipInstanceV1]:
    data = glitchtip_instance.query(query_func)
    return data.glitchtip_instances or []

# In the run method:
instances = get_glitchtip_instances(gql.get_api().query)
for inst in instances:
    # inst is a type-safe Pydantic object
    print(f"Processing Glitchtip instance: {inst.name}")
    # mypy will know that inst.read_token is a VaultSecretV1 object
    secret = get_secret(inst.read_token)

```

This workflow is the standard and recommended way to fetch data for new integrations.
